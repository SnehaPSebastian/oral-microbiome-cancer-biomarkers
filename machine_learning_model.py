# -*- coding: utf-8 -*-
"""Machine-Learning Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GBWdLbzPa08u66-9havc5ERr517NLIg1
"""

#Importing the genus table
from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#Importing the metadata table
from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#Importing the feature table
from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#Importing libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold, cross_val_predict
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import confusion_matrix, classification_report, roc_auc_score

# Step 1: Load YOUR OSCC microbiome data
genus_table = pd.read_csv("genus-table.tsv", sep='\t', skiprows=1, index_col=0)  # Skip BIOM header
metadata = pd.read_csv("Metadata_toba.tsv", sep='\t', index_col=0)

# Transpose: Samples as rows, genera as columns (sklearn format)
X = genus_table.T
y = metadata['Group']  # healthy vs OSCC/pre-cancerous

print(f"Features (genera): {X.shape[1]}, Samples: {X.shape[0]}")
print(f"Classes: {y.unique()}")

# Step 2: Data Cleaning
print("Missing values per genus:")
print(X.isnull().sum().sum())  # Usually 0

# Remove genera in <2 samples (sparse)
X = X.loc[:, (X > 0).sum() > 1]
print(f"After filtering: {X.shape}")

# Step 3: Encode labels and split
le = LabelEncoder()
y_encoded = le.fit_transform(y)
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded)

# Step 4: Scale (microbiome counts â†’ relative abundance recommended, but scaling works)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Step 5: Define models
models = {
    "Logistic Regression": LogisticRegression(max_iter=1000, random_state=42),
    "Random Forest": RandomForestClassifier(random_state=42),
    "Gradient Boosting": GradientBoostingClassifier(random_state=42),
    "K-Nearest Neighbors": KNeighborsClassifier(),
    "SVM": SVC(probability=True),
    "Naive Bayes": GaussianNB()
}

# Step 6: Cross-validation
print("\nCross-Validation Results (Accuracy & ROC-AUC):")

cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

for name, model in models.items():

    # Accuracy
    acc_scores = cross_val_score(
        model,
        X_train_scaled,
        y_train,
        cv=cv,
        scoring='accuracy')

    # Cross-validated probabilities
    if hasattr(model, "predict_proba"):
        y_cv_prob = cross_val_predict(
            model,
            X_train_scaled,
            y_train,
            cv=cv,
            method="predict_proba")

        roc_auc = roc_auc_score(
            y_train,
            y_cv_prob,
            multi_class="ovr",
            average="macro")

        print(f"{name}: Accuracy = {acc_scores.mean():.3f} | ROC-AUC = {roc_auc:.3f}")

    else:
        print(f"{name}: Accuracy = {acc_scores.mean():.3f} | ROC-AUC = Not available")

# Step 7: Train and evaluate
results = {}
for name, model in models.items():
    model.fit(X_train_scaled, y_train)
    y_pred = model.predict(X_test_scaled)

    print(f"\nClassification Report for {name}:")
    print(classification_report(y_test, y_pred, target_names=le.classes_))

    if hasattr(model, 'predict_proba'):
        # For multi-class classification, roc_auc_score requires
        # the probabilities for all classes and a multi_class strategy.
        # y_prob should be of shape (n_samples, n_classes)
        y_prob_full = model.predict_proba(X_test_scaled)
        roc_auc = roc_auc_score(y_test, y_prob_full, multi_class='ovr', average='weighted')
        print(f"ROC-AUC Score for {name}: {roc_auc:.3f}")
        results[name] = roc_auc

# Step 8: Visualize
plt.figure(figsize=(10, 6))
plot_names = list(results.keys())
plot_scores = list(results.values())
plt.bar(plot_names, plot_scores, color='lightcoral')
plt.xlabel('Model')
plt.ylabel('ROC-AUC Score')
plt.title('OSCC Microbiome Classification: Genus-Level Biomarkers')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.savefig('oscc_model_comparison.png', dpi=300, bbox_inches='tight')
plt.show()

# Step 9: Feature importance (Random Forest)
best_model = RandomForestClassifier(random_state=42)
best_model.fit(X_train_scaled, y_train)
importances = best_model.feature_importances_
feature_importance_df = pd.DataFrame({
    'genus': X.columns,
    'importance': importances
}).sort_values('importance', ascending=False)

print("\nTop 10 OSCC Biomarker Genera:")
print(feature_importance_df.head(10))
feature_importance_df.head(10).to_csv('oscc_top_biomarkers.csv')